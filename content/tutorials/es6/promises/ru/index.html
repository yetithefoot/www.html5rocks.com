{% extends "tutorial.html" %}
{% load mixin from templatefilters %}

{% block head %}
  {{ block.super }}
  <style>
    .get-example {
      display: none;
    }
    dt {
      display: block;
      margin: 0;
      font-weight: bold;
      color: #333;
    }
    dd {
      margin: 0 0 0.8em;
    }

    dl.inline dt {
      display: inline;
    }
    dl.inline dd {
      display: inline;
    }
    dl.inline dd::before {
      content:" - ";
    }
    dl.inline dd::after {
      content:"\A";
      white-space:pre;
    }
  </style>
{% endblock %}

{% block content %}

<p>Дамы и господа, приготовьтесь к поворотному моменту в истории веб-разработки...</p>
<p><em>[Барабанная дробь]</em></p>
<p>Promise'ы реализованы нативно в JavaScript!</p>
<p><em>[Фейерверки, конфети, толпа ликует]</em></p>
<p>Скорее всего, вы относитесь к одной из категорий:</p>

<ul>
  <li>Если вы не до конца понимаете, что такое promise'ы и как их использовать, тогда <a href="#toc-async">начните отсюда</a></li>
  <li>Вы уже используете promise'ы, но вас беспокоит, что все реализации имеют немного различный API. Хотите узнать как реализована официальная JavaScript версия? <a href="#toc-promise-terminology">В этом случае, начните отсюда</a></li>
  <li>Если же вы уже хорошо разбираетесь в том, как работают promise'ы, тогда переходите прямиком к <a href="#toc-api">API документации</a></li>
</ul>

<h2 id="toc-async">О чем речь?</h2>

<p>JavaScript однозадачный, это значит, что два куска кода не могут выполняться одновременно, а вынуждены выполняться один за другим. В браузерах JavaScript разделяет ресурсы потока с некоторыми другими инструкциями. Они отличаются от браузера к браузеру, но обычно JavaScript находится в одной очереди с инструкциями отрисовки страницы, обновления стилей, и обработки действий пользователя (таких как выделение текста и взаимодействие с элементами интерфейса). Выполнение любой из этих команд приостанавливает выполнение других.</p>
<p>Люди же многозадачные — вы можете печатать сразу несколькими пальцами, а можете одновременно вести машину и разговаривать. Единственная блокирующая операция — это когда вы чихаете, в этот момент все текущие действия временно прекращаются. Это раздражает, особенно, когда вы ведете машину и разговариваете. И уж точно, вы не хотите, чтобы ваш код «чихал».</p>
<p>Вероятно, раньше вы уже использовали события и колбеки. Например, так:</p>

<pre class="prettyprint">var img1 = document.querySelector('.img-1');

img1.addEventListener('load', function() {
  // изображение загрузилось
});

img1.addEventListener('error', function() {
  // что-то пошло не так
});</pre>

<p>Ничего сложного! Нашли изображение, добавили пару обработчиков, и JavaScript приостановит выполнение до тех пор, пока один из этих обработчиков не будет вызван.</p>
<p>К сожалению, в примере выше, возможна ситуация, когда событие произойдет раньше, чем мы начнем его слушать. Есть обходной путь, который использует свойство <code>complete</code> элемента <code>image</code>:</p>

<pre class="prettyprint">var img1 = document.querySelector('.img-1');

function loaded() {
  // изображение загрузилось
}

if (img1.complete) {
  loaded();
}
else {
  img1.addEventListener('load', loaded);
}

img1.addEventListener('error', function() {
  // что-то пошло не так
});</pre>

<p>Но это не поможет в ситуации, если ошибка произошла раньше, чем мы начали слушать событие <code>error</code>. К содалению, DOM не дает нам возможности сделать это. К тому же, этот код загружает только одно изображение, но всё становится гораздо сложнее, если мы хотим узнать, когда будет загружено несколько изображений. </p>

<h2 id="toc-events-not-always-best">События — не панацея</h2>

<p>События отлично подходят для тех случаев, когда событие происходит несколько раз в одном и том же элементе — <code>keyup</code>, <code>touchstart</code>. Используя события, не нужно знать, что происходило до того момента, как вы начали слушать эти события. Но когда дело доходит до обработки асинхронных событий с неопределённым исходом (success/failure), хотелось бы сделать так:</p>


<pre class="prettyprint">img1.callThisIfLoadedOrWhenLoaded(function() {
  // изображение загружено
}).orIfFailedCallThis(function() {
  // ошибка загрузки
});

// и…
whenAllTheseHaveLoaded([img1, img2]).callThis(function() {
  // все изображения загружены
}).orIfSomeFailedCallThis(function() {
  // произошла одна или несколько ошибок
});</pre>

<p>Promis'ы именно так и работают, но названия методов немного более внятные. Если у HTML элемента <code>image</code> был бы метод <code>ready</code>, возвращающий promise, мы могли бы переписать этот код так:</p>

<pre class="prettyprint">img1.ready().then(function() {
  // загружено
}, function() {
  // ошибка
});

// и…
Promise.all([img1.ready(), img2.ready()]).then(function() {
  // все изображения загружены
}, function() {
  // произошла одна или несколько ошибок
});</pre>

<p>В общем, promises немного похожи на обработчики событий, но:</p>

<ul>
  <li>Promise может либо успешно выполниться (succeed), либо завершиться с ошибкой (failed). Оно не может выполнить дважды  — либо только success, либо только failed.</li>
  <li>Если promise уже успешно выполнился (success) или произошла ошибка (failed), и после этого вы добавляете success/failure обработчик, то соответствующий обработчик вызовется, даже если событие уже произошло</li>
</ul>

<p>Это очень удобно для асинхронных операций, так как нужно обработать результаты этого события, не задумываясь о том, когда оно произошло.</p>

<h2 id="toc-promise-terminology">Терминология</h2>

<p>Когда <a href="https://twitter.com/domenic">Domenic Denicola</a> прочитал первую версию этой статьи, он поставил мне двойку за терминологию. Он заставил меня перечитать <a href="https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md">States and Fates</a> 100 раз, и вызвал родителей в школу. Несмотря на это, у меня в голове всё равно всё перемешалось, но вот основные понятия:</p>

<p>Promise'ы могут быть:</p>
<dl class="inline">
  <dt>fulfilled</dt>
  <dd>Действие, связанное с promise'ом успешно завершено</dd>
  <dt>rejected</dt>
  <dd>Действие, связанное с promise'ом завершено с ошибкой</dd>
  <dt>pending</dt>
  <dd>Promise пока не находится ни в одном из состояний: ни fulfilled, ни rejected</dd>
  <dt>settled</dt>
  <dd>Promise находится в одном из состояний: fulfilled или rejected</dd>
</dl>

<p><a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-promise-objects">В спецификации</a> также используется термин <strong>thenable</strong> для описания promise-подобного объекта, имеющего метод <code>then</code>. Но этот термин напоминает бывшего английского футбольного менеджера <a href="http://en.wikipedia.org/wiki/Terry_Venables">Терри Венейблса</a> поэтому я буду использовать его как можно реже.</p>

<h2 id="toc-javascript-promises">Promise'ы приходят в JavaScript!</h2>
<p>Существует уже достаточно много реализаций promises, например:</p>

<ul>
  <li><a href="https://github.com/kriskowal/q">Q</a></li>
  <li><a href="https://github.com/cujojs/when">when</a></li>
  <li><a href="http://msdn.microsoft.com/en-us/library/windows/apps/br211867.aspx">WinJS</a></li>
  <li><a href="https://github.com/tildeio/rsvp.js">RSVP.js</a></li>
</ul>

<p>Перечисленные выше и нативные JavaScript promise'ы придерживаются единого стандарта поведения, описанного в спецификации <a href="https://github.com/promises-aplus/promises-spec">Promises/A+</a>. Если вы используете jQuery, то наверняка использовали <a href="http://api.jquery.com/category/deferred-object/">Deferreds</a>. Однако, Deferreds несовместимы с Promise/A+ спецификацией, что делает их <a href="https://thewayofcode.wordpress.com/tag/jquery-deferred-broken/">немного менее удобными</a>. В jQuery есть ещё <a href="http://api.jquery.com/Types/#Promise">тип Promise</a>, но это всего лишь подмножество Deferred с теми же проблемами.</p>
<p>Несмотря на то, что реализайии promise  придерживаются стандартного поведения, их API немного отличается. Нативные JavaScript promise'ы очень похожи на API из RSVP.js. Вот как создается promise:</p>

<pre class="prettyprint">var promise = new Promise(function(resolve, reject) {
  // код, возможно асинхронный

  if (/* всё прошло удачно*/) {
    resolve("Работает!");
  }
  else {
    reject(Error("Не работает!"));
  }
});</pre>

<p>Конструктор принимает один аргумент, колбек с двумя параметрами, <code>resolve</code> и <code>reject</code>. Внутри этого колбека можно выполнять любые операции (в том числе и асинхронные). Потом вызываешь <code>resolve</code> если всё прошло удачно, или <code>reject</code> в случае ошибки.</p>
<p>Также как и для <code>throw</code> в JavaScript, в reject можно передать необязательный параметр <code>Error</code>. Польза от использования объекта <code>Error</code> в том, что они сохраняют стектрейс, тем самым делая отладку более удобной.</p>
<p>Вот как использовать promise'ы:</p>

<pre class="prettyprint">promise.then(function(result) {
  console.log(result); // "Stuff worked!"
}, function(err) {
  console.log(err); // Error: "It broke"
});</pre>

<p>Метод <code>then</code> принимает два аргумента, колбек success и колбек failure. Оба необязательные, так что вы сможете решать, передавать или не передавать success и failure.</p>
<p>Изначально promise'ы назывались Futures, потом были переименованы в Promises, и в итоге появились в JavaScript. А то, что они реализованы в JavaScript, а не в DOM, позволяет использовать их, например, в Node.js.</p>
<p>Но несмотря на то, что promise'ы — это фишка JavaScript, они могут активно используются в DOM. Все новые асинхронные DOM APIs будут их использовать. Например, <a href="https://dvcs.w3.org/hg/quota/raw-file/tip/Overview.html#idl-def-StorageQuota">Quota Management</a>, <a href="http://dev.w3.org/csswg/css-font-loading/#font-face-set-ready">Font Load Events</a>,<a href="https://github.com/slightlyoff/ServiceWorker/blob/cf459d473ae09f6994e8539113d277cbd2bce939/service_worker.ts#L17"> ServiceWorker</a>, <a href="http://webaudio.github.io/web-midi-api/#widl-Navigator-requestMIDIAccess-Promise-MIDIOptions-options">Web MIDI</a>, <a href="https://github.com/whatwg/streams#basereadablestream">Streams</a>, и многие другие.</p>

<h2 id="toc-browser-support">Поддержка в браузерах и polyfill</h2>
<p>Начиная с Chrome 32 и Opera 19, поддержка  promise'ов включена по умолчанию. В Firefox promise'ы доступны в, <a href="http://nightly.mozilla.org/">ночной сборке</a>, и пока поддерживаются <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=918806">частично</a>.</p>

<p>Если вы хотите добавить эту поддержку в другие браузеры или Node.js, воспользуйте этот <a href="https://github.com/jakearchibald/ES6-Promises#readme">polyfill</a>.</p>

<h2 id="toc-lib-compatibility">Совместимость с другими библиотеками</h2>
<p>Нативные JavaScript promise'ы используют метод <code>then</code> , так что если ваша бибилиотека возвращает Q promise, всё должно работать.</p>
<p>Но, как было отмечено ранее, объект Deferred из jQuery немного другой. Но вы можете привести его к виду, соответствующему спецификации с помощью метода <code>cast</code>:</p>

<pre class="prettyprint">var jsPromise = Promise.resolve($.ajax('/whatever.json'));</pre>

<p>Здесь, метод jQuery <code>$.ajax</code> возвращает Deferred. Но так как у него есть метод <code>Promise.resolve</code> его можно преобразовать в нативный promise. Тем не менее, иногда deferred'ы передают слишком много аргументов в колбеки:</p>

<pre class="prettyprint">var jqDeferred = $.ajax('/whatever.json');

jqDeferred.then(function(response, statusText, xhrObj) {
  // ...
}, function(xhrObj, textStatus, err) {
  // ...
});</pre>

<p>А нативные promise'ы игнорируют все, кроме первого:</p>

<pre class="prettyprint">jsPromise.then(function(response) {
  // ...
}, function(xhrObj) {
  // ...
});</pre>

<p>Кроме того, jQuery не следует общему правилу и не передает объект <code>Error</code> в колбеки.</p>

<h2 id="toc-coding-with-promises">Асинхронность становится проще</h2>
<p>OK, напишем что-нибудь. Например мы хотим:</p>

<ol>
  <li>Показать индикатор процесса загрузки</li>
  <li>Получить объект рассказа в формате JSON, содержащий название и URL каждой главы</li>
  <li>Добвыить заголовок на страницу</li>
  <li>Загрузить все главы</li>
  <li>Добавить главы на страницу</li>
  <li>Убрать индикатор загрузки</li>
</ol>

<p>…а ещё нужно нотифицировать пользователя, если что-то пойдет не так. В этом случае тоже нужно будет убрать индикатор загрузки.</p>
<p>Конечно, быстрее было бы, <a href="http://jakearchibald.com/2013/progressive-enhancement-is-faster/">вернуть всё в HTML</a>, но наш подход хорош.</p>

<p>Начнем, сначала нужно получить данные из сети:</p>

<h2 id="toc-promisifying-xmlhttprequest">Promise'ы и XMLHttpRequest</h2>

<p>Старый API постепенно переписывается и в него добавляется поддержка promise'ов. <code>XMLHttpRequest</code> — первый кандидат, а пока давайте напишем простую функцию отправляющую GET запрос:</p>

<pre class="prettyprint">function get(url) {
  // Вернем promise
  return new Promise(function(resolve, reject) {
    // Используем XHR как обычно
    var req = new XMLHttpRequest();
    req.open('GET', url);

    req.onload = function() {
      // этот обработчик срабатывает всегда (даже для 404)
      // поэтому проверяем статус
      if (req.status == 200) {
        // Успешно завершаем promise и передаем текст ответа 
        resolve(req.response);
      }
      else {
        // завершаем promise с ошибкой и передаем текст ошибки
        reject(Error(req.statusText));
      }
    };

    // отслеживаем ошибки сети
    req.onerror = function() {
      reject(Error("Network Error"));
    };

    // отправляем запрос
    req.send();
  });
}</pre>

<p>Теперь используем эту функцию:</p>

<pre class="prettyprint">get('story.json').then(function(response) {
  console.log("Успешно!", response);
}, function(error) {
  console.error("Ошибка!", error);
});</pre>

<p><span class="live-example get-example"><a href="story.json">Нажмите сюда, чтобы посмотреть в действии</a>, откройте консоль в DevTools, чтобы увидеть результат.</span> Теперь мы можем отправлять HTTP запросы без постоянного написания <code>XMLHttpRequest</code>, что, само по себе, очень удобно.</p>

<h2 id="toc-chaining">Цепочки вызовов</h2>
<p>Метод <code>then</code> – это ещё не всё. Вы можете объединить вызовы <code>then</code> вместе для конвейерного изменения значений или последовательного выполнения асинхронных задач.</p>

<h3 id="toc-transforming-values">Конвейерное изменение значений</h3>
<p>Вы можете изменять значение просто возвращая его из promise'а:</p>

<pre class="prettyprint">var promise = new Promise(function(resolve, reject) {
  resolve(1);
});

promise.then(function(val) {
  console.log(val); // 1
  return val + 2;
}).then(function(val) {
  console.log(val); // 3
});</pre>

<p>НУ, и более практический пример:</p>

<pre class="prettyprint">get('story.json').then(function(response) {
  console.log("Успешно выполнено!", response);
});</pre>

<p>Сервер ответил в формате JSON, но передал ответ как text/plain. Мы можем заставить функцию возвращать JSON объект, выставив соответствующий <code><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#responseType">responseType</a></code>, а можем решить это с помощью promise'ов:</p>

<pre class="prettyprint">get('story.json').then(function(response) {
  return JSON.parse(response);
}).then(function(response) {
  console.log("Ура, JSON!", response);
});</pre>

<p>Так как функция <code>JSON.parse</code> принимает один агрумент и возвращает измененное значение, мы можем сократить этот код:</p>

<pre class="prettyprint">get('story.json').then(JSON.parse).then(function(response) {
  console.log("Ура, JSON!", response);
});</pre>

<p><span class="live-example json-example"><a href="story.json">Посмотреть демо</a>, откройте консоль DevTools чтобы увидеть результат.</span> Вообще, можем написать функцию <code>getJSON</code>:</p>

<pre class="prettyprint">function getJSON(url) {
  return get(url).then(JSON.parse);
}</pre>

<p><code>getJSON</code> возвращает promise, который вытягивает данные по url, потом парсит данные и возвращает JSON объект.</p>

<h3 id="toc-promises-queues">Последовательное выполнение асинхронных задач</h3>
<p>Также, мы можем связывать вызовы <code>then</code> в цепочку, чтобы последовательно выполнять асинхронные задачи.</p>
<p>Когда вы возвращаете что-то из колбека <code>then</code>, происходит немного магии. Если вы возвращаете значеие, следующий <code>then</code> в цепочке вызовется с этим значением. Но если вы возвращаете promise, то следующий <code>then</code> будет ждать выполнения этого promise'а, и будет вызван только тогда, когда promise разрешится (succeeds/fails). Например:</p>

<pre class="prettyprint">getJSON('story.json').then(function(story) {
  return getJSON(story.chapterUrls[0]);
}).then(function(chapter1) {
  console.log("Загрузили главу 1!", chapter1);
});</pre>

<p>Здесь мы делаем асинхронный запрос к <code>story.json</code>, который возвращает нам URL адреса для запросов, после чего мы делаем запрос к первому из них. Намного круче, чем обычные колбеки.

 Напишем функцию получения текста главы:</p>

<pre class="prettyprint">var storyPromise;

function getChapter(i) {
  storyPromise = storyPromise || getJSON('story.json');

  return storyPromise.then(function(story) {
    return getJSON(story.chapterUrls[i]);
  })
}

// дальше используем вот так:
getChapter(0).then(function(chapter) {
  console.log(chapter);
  return getChapter(1);
}).then(function(chapter) {
  console.log(chapter);
});</pre>

<p>Мы не загружаем <code>story.json</code> до тех пор пока метод <code>getChapter</code> не будет вызван, но в следующие разы, когда <code>getChapter</code> будет вызван, мы просто переиспользуем storyPromise, и, таким образом, <code>story.json</code> будет загружен только один раз.</p>

<h2 id="toc-error-handling">Обработка ошибок</h2>
<p>Как мы увидели ранее, <code>then</code> принимает два аргумента, один (success/fulfill) для успешного завершения, другой (failure/reject) для ошибочного:</p>

<pre class="prettyprint">get('story.json').then(function(response) {
  console.log("Успешно!", response);
}, function(error) {
  console.log("Ошибка!", error);
});</pre>

<p>Также можно использовать <code>catch</code>:</p>

<pre class="prettyprint">get('story.json').then(function(response) {
  console.log("Успешно!", response);
}).catch(function(error) {
  console.log("Ошибка!", error);
});</pre>

<p>Метод <code>catch</code>, это всего лишь более читаемый синтаксический сахар для <code>then(undefined, func)</code>. Заметьте, что два примера кода выше немного разные, последний эквивалентен:</p>

<pre class="prettyprint">get('story.json').then(function(response) {
  console.log("Успешно!", response);
}).then(undefined, function(error) {
  console.log("Ошибка!", error);
});</pre>

<p>Эта небольшая разница, открывает широкие возможности. Отказы promise'ов проскакивают до следующего <code>then</code> с указанным failed колбеком (или до <code>catch</code>, так как это одно и то же). Для ситуации <code>then(func1, func2)</code>, будет вызвана только одна из функций <code>func1</code> или <code>func2</code>, но не обе. Но для случая <code>then(func1).catch(func2)</code>, функция <code>func2</code> может быть вызвана, если в функции <code>func1</code> случится ошибка, так как это разные шаги в цепочке. Посмотрите на этот пример:</p>

<pre class="prettyprint">asyncThing1().then(function() {
  return asyncThing2();
}).then(function() {
  return asyncThing3();
}).catch(function(err) {
  return asyncRecovery1();
}).then(function() {
  return asyncThing4();
}, function(err) {
  return asyncRecovery2();
}).catch(function(err) {
  console.log("Не беспокойся об этом");
}).then(function() {
  console.log("Всё готово!");
});</pre>

<p>Это очень похоже на обычный try/catch в JavaScript. Если в блоке <code>try</code> произойдет ошибка, то мы сразу попадем в блок <code>catch</code>. Вот блок-схема иллюстрирующая код выше (потому что я люблю блок-схемы):</p>

<div style="max-width: 495px; margin: 10px auto">
  <div style="position: relative; padding-top: 93%;">
    <iframe style="position:absolute;top:0;left:0;width:100%;height:100%;overflow:hidden" src="promise-flow.svg" frameborder="0" allowtransparency="true"></iframe>
  </div>
</div>

<p>Зеленые стрелки — удачный сценарий, красные — ошибочный.</p>

<h3 id="toc-exceptions-and-promises">Исключения JavaScript и promise'ы</h3>
<p>Ошибочный сценарий возникает внутри promise не только когда был явно вызван <code>reject</code>, но ещё и неявно, когда внутри переданного колбека было сгенерировано исключение:</p>

<pre class="prettyprint">var jsonPromise = new Promise(function(resolve, reject) {
  // JSON.parse сгенерирует ошибку, если ему передать некорректный JSON
  // в таком случае произойдет неявный reject:
  resolve(JSON.parse("Это некорректный JSON"));
});

jsonPromise.then(function(data) {
  // никогда не произойдет
  console.log("Работает!", data);
}).catch(function(err) {
  // произойдет
  console.log("Не работает!", err);
});</pre>

<p>Это значит, что если делать всю работу внутри переданного колбека, то все произошедшие ошибки автоматически приведут к reject.</p>
<p>Это же правило работает для колбеков, передвнных в метод <code>then</code>.</p>

<pre class="prettyprint">get('/').then(JSON.parse).then(function() {
  // никогда не произойдет, так как '/' это HTML страница, а не JSON
  // JSON.parse сгенерирует ошибку 
  console.log("Работает!", data);
}).catch(function(err) {
  // произойдет
  console.log("Не работает", err);
});</pre>

<h3 id="toc-errors-in-practice">Обработка ощибок на практике</h3>

<p>В случае с нашей историей, разбитой на главы, мы можем использовать catch, чтобы оповестить пользователя о произошедшей ошибке:</p>

<pre class="prettyprint">getJSON('story.json').then(function(story) {
  return getJSON(story.chapterUrls[0]);
}).then(function(chapter1) {
  addHtmlToPage(chapter1.html);
}).catch(function() {
  addTextToPage("Невозможно загрузить главу");
}).then(function() {
  document.querySelector('.spinner').style.display = 'none';
});</pre>

<p>Если процесс загрузки <code>story.chapterUrls[0]</code> не удастся (например, сервер вернет ошибку 500 или отсутствует подключени к сети), то выполнение функции пропустит все колбеки success. В этом случае не выполнится' функция <code>getJSON</code>, которая парсит JSON. Также не выполнится функция добавляющая текст chapter1.html на страницу. Вместо этого, управление сразу передастся в колбек <code>catch</code>. В итоге, на страницу будет добавлен текст "Невозможно загрузить главу", если в любой предыдущей функции произойдет ошибка.</p>
<p>Как и в случае с обычным try/catch, ошибка будет перехвачена, и код, скрывающий индикатор загрузки, выполнится, что нам и нужно. Вот как выглядела бы блокирующая версия этого кода:</p>

<pre class="prettyprint">try {
  var story = getJSONSync('story.json');
  var chapter1 = getJSONSync(story.chapterUrls[0]);
  addHtmlToPage(chapter1.html);
}
catch (e) {
  addTextToPage("Невозможно загрузить главу");
}

document.querySelector('.spinner').style.display = 'none';</pre>

<p>Можно также использовать <code>catch</code> только для вывода ошибок. Для этого нужно выполнить свой код (вывод текста ошибки) и заново сгенерировать ошибку. Вот как мы можем это сделать в функции <code>getJSON</code>:</p>

<pre class="prettyprint">function getJSON(url) {
  return get(url).then(JSON.parse).catch(function(err) {
    console.log("В getJSON произошла ощибка ", url, err);
    throw err;
  });
}</pre>

<p>Итак мы успешно загрузили одну главу. Настало время загрузить остальные.</p>

<h2 id="toc-parallelism-sequencing">Параллельно и последовательно - выбираем лучшее</h2>

<p>Думать асинхронно нелегко. Если вы зашли в тупик, пишите код так, как будто он синхронный:</p>

<pre class="prettyprint">try {
  var story = getJSONSync('story.json');
  addHtmlToPage(story.heading);

  story.chapterUrls.forEach(function(chapterUrl) {
    var chapter = getJSONSync(chapterUrl);
    addHtmlToPage(chapter.html);
  });

  addTextToPage("Готово");
}
catch (err) {
  addTextToPage("Ошибка: " + err.message);
}

document.querySelector('.spinner').style.display = 'none';</pre>

<p>Это будет работать (<a href="sync-example.html">смотреть демо</a>)! Но этот код синхронный и блокирует выполнение пока данные загружаются. Чтобы добавить асинхронности, используем метод <code>then</code>:</p>

<pre class="prettyprint">getJSON('story.json').then(function(story) {
  addHtmlToPage(story.heading);

  // TODO: для каждого url из story.chapterUrls, загружаем и показываем
}).then(function() {
  // всё готово
  addTextToPage("Готово");
}).catch(function(err) {
  // ловим любые ошибки
  addTextToPage("Ошибка: " + err.message);
}).then(function() {
  // всегда скрываем индикатор
  document.querySelector('.spinner').style.display = 'none';
});</pre>

<p>Но как же получить все главы в нужном порядке? Так <strong>не работает</strong>:</p>

<pre class="prettyprint">story.chapterUrls.forEach(function(chapterUrl) {
  // получаем главу
  getJSON(chapterUrl).then(function(chapter) {
    // добавляем на страницу
    addHtmlToPage(chapter.html);
  });
});</pre>

<p><code>forEach</code> ничего не знает об асинхронности, поэтому наши главы появятся в произвольном порядке по мере загрузки. Нам же не нужна статья в стиле «Криминального чтива», давайте поправим…</p>

<h3 id="toc-creating-sequences">Создание очереди выполнения</h3>
<p>Чтобы превратить массив <code>chapterUrls</code> в очередь promise'ов, используем уже известный метод <code>then</code>:</p>

<pre class="prettyprint">// Создадим promise, который всегда разрешается успешно
var sequence = Promise.resolve();

// пробегаем по все главам
story.chapterUrls.forEach(function(chapterUrl) {
  // и добавляем эти действия в конец очереди
  sequence = sequence.then(function() {
    return getJSON(chapterUrl);
  }).then(function(chapter) {
    addHtmlToPage(chapter.html);
  });
});</pre>

<p>Здесь мы в первый раз увидели метод <code>Promise.resolve</code>, который успешно выполнится с любым переданным ему значением. Если же передать ему что-то промисообразное (имеющее метод <code>then</code>), то будет возвращен новый <code>promise</code>. Если передать, например <code>Promise.resolve('Hello')</code>, будет создан <code>promise</code>, который успешно разрешится с этим значением. Если вызвать этот метод без параметров, то <code>promise</code> успешно разрешится со значением <code>undefined</code>.</p>

<p>Также есть метод <code>Promise.reject(val)</code>, который создает <code>promise</code>, который будет отклонён с переданным значением (или <code>undefined</code>)</p>
<p>С использованием <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">array.reduce</a></code> наш код станет немного изящнее:</p>

<pre class="prettyprint">// пробегаем по списку глав
story.chapterUrls.reduce(function(sequence, chapterUrl) {
  // добавляем все действия в очередь
  return sequence.then(function() {
    return getJSON(chapterUrl);
  }).then(function(chapter) {
    addHtmlToPage(chapter.html);
  });
}, Promise.resolve());</pre>

<p>Этот код делает то же самое, что и предыдущий пример, но здесь не требуется выделять отдельную переменную <code>sequence</code> для очереди. Колбэк вызовется для каждого элемента массива, а результат будет накапливаться в переменной <code>sequence</code>, которая изначально была проинициализирована методом <code>Promise.resolve()</code>. При каждом вызове колбэка ему передаётся результат предыдущего вызова. <code>array.reduce</code> удобно использовать, когда необходимо собрать в одной переменной, например, в promise'e.</p>
<p>Теперь соберем всё вместе…</p>

<pre class="prettyprint">getJSON('story.json').then(function(story) {
  addHtmlToPage(story.heading);

  return story.chapterUrls.reduce(function(sequence, chapterUrl) {
    // Как только глава будет загружена
    return sequence.then(function() {
      // загрузим следующую
      return getJSON(chapterUrl);
    }).then(function(chapter) {
      // и добавим на страницу
      addHtmlToPage(chapter.html);
    });
  }, Promise.resolve());
}).then(function() {
  // всё готово
  addTextToPage("Готово");
}).catch(function(err) {
  // ловим любые ошибки
  addTextToPage("Ошибка: " + err.message);
}).then(function() {
  // всегда скрываем индикатор
  document.querySelector('.spinner').style.display = 'none';
});</pre>

<p>И всё (<a href="async-example.html">смотри демо</a>), мы написали полностью асинхронный код. Но можем сделать ещё лучше. Сейчас страница грузится так:</p>

<figure>
  <img src="promise1.gif">
</figure>

<p>Браузеры могут выполнять несколько запросов одновременно, так что мы немного теряем в производительности, загружая главы последовательно. Мы же хотим загрузить их одновременно, а затем, по окончании загрузки, обработать их. К счастью, для этого тоже есть удобный API:</p>

<pre class="prettyprint">Promise.all(arrayOfPromises).then(function(arrayOfResults) {
  //...
});</pre>

<p><code>Promise.all</code> принимает массив promise'ов и создает новый promise который выполнится, когда выполнятся переданные ему promise'ы. В результате, вы получите массив результатов promise'ов в том порядке, в котором они находились в массиве.</p>

<pre class="prettyprint">getJSON('story.json').then(function(story) {
  addHtmlToPage(story.heading);

  // передаем массив promise'ов и ждем выполнения всех
  return Promise.all(
    // получаем данные для каждого url
    story.chapterUrls.map(getJSON)
  );
}).then(function(chapters) {
  // мы получили текст всех глав
  chapters.forEach(function(chapter) {
    // добавим их на страницу
    addHtmlToPage(chapter.html);
  });
  addTextToPage("Готово");
}).catch(function(err) {
  // ловим любые ошибки
  addTextToPage("Ошибка: " + err.message);
}).then(function() {
  document.querySelector('.spinner').style.display = 'none';
});</pre>

<p>Мы выиграли немного времени (<a href="async-all-example.html">смотри демо</a>) и сократили количество строк кода. Главы могут быть загружены в в любой последовательности, но на экране появятся в правильном порядке.</p>

<figure>
  <img src="promise2.gif">
</figure>

<p>Однако, мы можем ещё улучшить этот пример. Когда первая глава будет загружена, мы должны добавить её на страницу, чтобы пользователь начал читать, не дожидаясь остальные главы. Но, например, когда будет загружена третья глава, мы не должны добавлять её на страницу, так как предыдущие главы еще не загрузились.</p>
<p>Чтобы сделать это, будем получать JSON всех глав одновременно, а потом создадим очередь для добавления их на страницу:</p>

<pre class="prettyprint">getJSON('story.json').then(function(story) {
  addHtmlToPage(story.heading);

  // получаем данные для каждого url
  // они будут загружаться параллельно
  return story.chapterUrls.map(getJSON)
    .reduce(function(sequence, chapterPromise) {
      // используем метод reduce чтобы собрать promise'ы вместе
      return sequence.then(function() {
        // и запускаем обработку каждого раздела
        return chapterPromise;
      }).then(function(chapter) {
        addHtmlToPage(chapter.html);
      });
    }, Promise.resolve());
}).then(function() {
  addTextToPage("Готово");
}).catch(function(err) {
  // ловим любые ошибки
  addTextToPage("Ошибка: " + err.message);
}).then(function() {
  document.querySelector('.spinner').style.display = 'none';
});</pre>

<p>Вот и всё (<a href="async-best-example.html">смотри демо</a>), идеальный код! Сначала загружаем все главы параллельно, , потом обрабатываем каждую в нужном порядке.</p>

<figure>
  <img src="promise3.gif">
</figure>

<p>В этом примере, главы достаточно маленькие, но если их будет больше, то разница будет более заметна.</p>

<p>Если бы мы писали этот код <a href="https://gist.github.com/jakearchibald/0e652d95c07442f205ce">в стиле Node.js c колбеками</a> кода было бы больше, а понимать его было бы сложнее. Однако, это ещё не всё. Используя promise'ы вместе с другими возможностями ES6 features всё можеn cnfnm ещё проще…</p>

<h2 class="toc-generators">Бонус: Promise'ы и генераторы</h2>

<p>This next bit involves a whole bunch of new ES6 features, but it's not something you need to understand to use promises in your code today. Treat it like a movie trailer for some upcoming blockbuster features.</p>
<p>ES6 also gives us <a href="http://wiki.ecmascript.org/doku.php?id=harmony:generators">generators</a>, which allow functions to exit at a particular point, like "return", but later resume from the same point and state. Eg:</p>

<pre class="prettyprint">function *addGenerator() {
  var i = 0;
  while (true) {
    i += yield i;
  }
}</pre>

<p>Notice the star before the function name, this makes it a generator. The yield keyword is our return/resume point. We can use it like this:</p>

<pre class="prettyprint">var adder = addGenerator();
adder.next().value; // 0
adder.next(5).value; // 5
adder.next(5).value; // 10
adder.next(5).value; // 15
adder.next(50).value; // 65</pre>

<p>But what does this mean for promises? Well, you can use this return/resume behaviour to write async code that looks (and is as easy to follow as) synchronous code. Don't worry too much about understanding it line-for-line, but here's a helper function that lets us use 'yield' to wait for promises to settle:</p>

<pre class="prettyprint">function spawn(generatorFunc) {
  function continuer(verb, arg) {
    var result;
    try {
      result = generator[verb](arg);
    } catch (err) {
      return Promise.reject(err);
    }
    if (result.done) {
      return result.value;
    } else {
      return Promise.resolve(result.value).then(onFulfilled, onRejected);
    }
  }
  var generator = generatorFunc();
  var onFulfilled = continuer.bind(continuer, "next");
  var onRejected = continuer.bind(continuer, "throw");
  return onFulfilled();
}</pre>

<p>…which I pretty much <a href="https://github.com/kriskowal/q/blob/db9220d714b16b96a05e9a037fa44ce581715e41/q.js#L500">lifted verbatim from Q</a>, but adapted for JavaScript promises. With this, we can take our final best-case chapter example, mix it with a load of new ES6 goodness, and turn it into:</p>

<pre class="prettyprint">spawn(function *() {
  try {
    // 'yield' effectively does an async wait,
    // returning the result of the promise
    let story = yield getJSON('story.json');
    addHtmlToPage(story.heading);

    // Map our array of chapter urls to
    // an array of chapter json promises.
    // This makes sure they all download parallel.
    let chapterPromises = story.chapterUrls.map(getJSON);

    for (let chapterPromise of chapterPromises) {
      // Wait for each chapter to be ready, then add it to the page
      let chapter = yield chapterPromise;
      addHtmlToPage(chapter.html);
    }

    addTextToPage("All done");
  }
  catch (err) {
    // try/catch just works, rejected promises are thrown here
    addTextToPage("Argh, broken: " + err.message);
  }
  document.querySelector('.spinner').style.display = 'none';
});</pre>

<p>This works exactly as before, but so much easier to read. This works in Chrome and Opera today (<a href="async-generators-example.html">see example</a>), but first you need to go to <strong>about:flags</strong> and turn on <strong>Enable experimental JavaScript</strong>.</p>

<p>This throws together a lot of new ES6 stuff: promises, generators, let, for-of. When we yield a promise, the spawn helper waits for the promise to resolve and returns the final value. If the promise rejects, spawn causes our yield statement to throw an exception, which we can catch with normal JavaScript try/catch. Amazingly simple async coding!</p>

<h2 id="toc-api">Promise API Reference</h2>

<p>All methods work in Chrome, Opera and in Firefox Nightly unless otherwise noted. <a href="https://github.com/jakearchibald/ES6-Promises#readme">The polyfill</a> provides the below for all browers.</p>

<h3>Static Methods</h3>
<dl>
  <dt><code>Promise.resolve(promise);</code></dt>
  <dd>Returns promise (only if <code>promise.constructor == Promise</code>)
  <dt><code>Promise.resolve(thenable);</code></dt>
  <dd>Make a new promise from the thenable. A thenable is promise-like in as far as it has a "then" method.
  </dd>
  <dt><code>Promise.resolve(obj);</code></dt>
  <dd>Make a promise that fulfills to <code>obj</code>.</code> in this situation.</dd>
  <dt><code>Promise.reject(obj);</code></dt>
  <dd>Make a promise that rejects to <code>obj</code>. For consistency and debugging (e.g. stack traces), <code>obj</code> should be an <code>instanceof Error</code>.</dd>
  <dt><code>Promise.all(array);</code></dt>
  <dd>Make a promise that fulfills when every item in the array fulfills, and rejects if (and when) any item rejects. Each array item is passed to <code>Promise.resolve</code>, so the array can be a mixture of promise-like objects and other objects. The fulfillment value is an array (in order) of fulfillment values. The rejection value is the first rejection value.
  <p class="notice"><b>Note:</b> Only implemented in Chrome and Opera so far</p></dd>
  <dt><code>Promise.race(array);</code></dt>
  <dd>Make a Promise that fulfills as soon as any item fulfills, or rejects as soon as any item rejects, whichever happens first.
  <p class="notice"><b>Note:</b> Only implemented in Chrome and Opera. Also, I'm unconvinced of its usefulness; I'd rather have an opposite of <code>Promise.all</code> that only rejected if all items rejected.</p></dd>
</dl>

<h3>Constructor</h3>
<pre class="prettyprint">new Promise(function(resolve, reject) {});</pre>
<dl>
  <dt><code>resolve(thenable)</code></dt>
  <dd>Your promise will be fulfilled/rejected with the outcome of <code>thenable</code></dd>
  <dt><code>resolve(obj)</code></dt>
  <dd>Your promise is fulfilled with <code>obj</code></dd>
  <dt><code>reject(obj)</code></dt>
  <dd>Your promise is rejected with <code>obj</code>. For consistency and debugging (eg stack traces), obj should be an <code>instanceof Error</code>. Any errors thrown in the constructor callback will be implicitly passed to <code>reject()</code>.</dd>
</dl>

<h3>Instance Methods</h3>
<dl>
  <dt><code>promise.then(onFulfilled, onRejected)</code></dt>
  <dd><code>onFulfilled</code> is called when/if "promise" resolves.
  <code>onRejected</code> is called when/if "promise" rejects.
  Both are optional, if either/both are omitted the next <code>onFulfilled</code>/<code>onRejected</code> in the chain is called.
  Both callbacks have a single parameter, the fulfillment value or rejection reason.
  "then" returns a new promise equivalent to the value you return from <code>onFulfilled</code>/<code>onRejected</code> after being passed through <code>Promise.resolve</code>. If an error is thrown in the callback, the returned promise rejects with that error.</dd>
  <dt><code>promise.catch(onRejected)</code></dt>
  <dd>Sugar for <code>promise.then(undefined, onRejected)</code></dd>
</dl>

<p>Many thanks to Anne van Kesteren, Domenic Denicola, Tom Ashworth, Remy Sharp, Addy Osmani, Arthur Evans, and Yutaka Hirano who proofread this and made corrections/recommendations.</p>

<p>Also, thanks to <a href="http://mathiasbynens.be/">Mathias Bynens</a> for <a href="https://github.com/html5rocks/www.html5rocks.com/pull/921/files">updating various parts</a> of the article.</p>

<script src="promise-2.0.4.min.js"></script>
<script>
  function get(url) {
    // Return a new promise.
    // We do all the work within the constructor callback, so we can return here
    return new Promise(function(resolve, reject) {
      // Do the usual XHR stuff
      var req = new XMLHttpRequest();
      req.open('GET', url);

      req.onload = function() {
        // This is called even on 404 etc
        // so check the status
        if (req.status == 200) {
          // Resolve the promise with the response text
          resolve(req.response);
        }
        else {
          // Otherwise reject with the status text
          // which will hopefully be a meaningful error
          reject(Error(req.statusText));
        }
      };

      // Handle network errors
      req.onerror = function() {
        reject(Error("Network Error"));
      };

      // Make the request
      req.send();
    });
  }

  Array.prototype.slice.call(document.querySelectorAll('.live-example')).forEach(function(el) {
    el.style.display = "inline";
  });

  document.querySelector('.get-example a').addEventListener('click', function(event) {
    get(this.href).then(
      console.log.bind(console, "Success!"),
      console.error.bind(console, "Failure!")
    );
    event.preventDefault();
  });

  document.querySelector('.json-example a').addEventListener('click', function(event) {
    get(this.href).then(JSON.parse).then(
      console.log.bind(console, "Success!"),
      console.error.bind(console, "Failure!")
    );
    event.preventDefault();
  });
</script>

{% endblock %}
